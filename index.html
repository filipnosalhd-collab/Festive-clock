<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>≈öwiƒÖteczny Zegar</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", sans-serif;
        overflow: hidden;
      }
      #c {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #clock {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 100;
        pointer-events: none;
      }
      #time {
        font-size: clamp(3rem, 12vw, 8rem);
        font-weight: bold;
        color: #fff;
        text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.7),
          0 0 40px rgba(255, 255, 255, 0.3);
      }
      #date {
        font-size: clamp(1rem, 4vw, 2rem);
        color: #fff;
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
        margin-top: 10px;
      }
      #hname {
        font-size: clamp(1.2rem, 5vw, 2.5rem);
        color: #ffd700;
        text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
        margin-top: 20px;
        font-weight: bold;
      }
      #count {
        font-size: clamp(0.8rem, 3vw, 1.2rem);
        color: #fff;
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
        margin-top: 15px;
      }
      #sbtn {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }
      #sbtn:hover {
        transform: rotate(90deg);
      }
      #sbtn svg {
        width: 24px;
        height: 24px;
        fill: #fff;
      }
      #sndbtn {
        position: fixed;
        top: 20px;
        right: 80px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        z-index: 1000;
        backdrop-filter: blur(10px);
        font-size: 24px;
        transition: all 0.3s;
      }
      #sndbtn:hover {
        background: rgba(255, 255, 255, 0.3);
      }
      #sndbtn.muted {
        opacity: 0.5;
      }
      #spanel {
        position: fixed;
        top: 0;
        right: -420px;
        width: min(420px, 95vw);
        height: 100vh;
        background: rgba(20, 20, 40, 0.97);
        z-index: 999;
        transition: right 0.4s;
        overflow-y: auto;
        padding: 25px;
      }
      #spanel.open {
        right: 0;
      }
      #spanel h2 {
        color: #fff;
        margin-bottom: 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 15px;
      }
      .hi {
        background: rgba(255, 255, 255, 0.08);
        padding: 15px;
        margin-bottom: 12px;
        border-radius: 12px;
      }
      .hh {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      .hn {
        color: #ffd700;
        font-weight: bold;
      }
      .hd {
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.85rem;
      }
      .ci {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
      }
      .cg {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
      }
      .cg label {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.6);
      }
      .cg input {
        width: 45px;
        height: 35px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
      }
      #tz {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 100;
      }
      #tz select {
        padding: 12px;
        background: rgba(0, 0, 0, 0.4);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
      }
      .pb {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: #fff;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 10px;
      }
      .pb.active {
        background: linear-gradient(135deg, #f093fb, #f5576c);
      }
      .pl {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.75rem;
        margin-top: 8px;
      }
      .cls {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: #fff;
        font-size: 28px;
        cursor: pointer;
      }
      #hsearch {
        position: sticky;
        top: 0;
        background: rgba(30, 30, 60, 0.95);
        padding: 10px 0 15px 0;
        margin-bottom: 10px;
        z-index: 10;
        display: flex;
        gap: 8px;
      }
      #searchInput {
        flex: 1;
        padding: 12px 15px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        color: #fff;
        font-size: 1rem;
      }
      #searchInput::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }
      #clearSearch {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: #fff;
        width: 40px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1.1rem;
      }
      #clearSearch:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .hi.hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="clock">
      <div id="time">00:00:00</div>
      <div id="date"></div>
      <div id="hname"></div>
      <div id="count"></div>
    </div>
    <button id="sbtn">
      <svg viewBox="0 0 24 24">
        <path
          d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"
        />
      </svg>
    </button>
    <button id="sndbtn" onclick="toggleSound()">üîä</button>
    <div id="spanel">
      <button class="cls" onclick="toggleSettings()">√ó</button>
      <h2>‚öôÔ∏è Ustawienia</h2>
      <div id="hsearch">
        <input
          type="text"
          id="searchInput"
          placeholder="üîç Szukaj ≈õwiƒôta..."
          oninput="filterHolidays(this.value)"
        /><button id="clearSearch" onclick="clearSearch()">‚úï</button>
      </div>
      <div id="hset"></div>
    </div>
    <div id="tz">
      <select onchange="tz=this.value">
        <option value="Europe/Warsaw">üáµüá± Polska</option>
        <option value="Europe/London">üá¨üáß Londyn</option>
        <option value="Europe/Berlin">üá©üá™ Berlin</option>
        <option value="America/New_York">üá∫üá∏ Nowy Jork</option>
        <option value="Asia/Tokyo">üáØüáµ Tokio</option>
      </select>
    </div>
    <script>
      const cv = document.getElementById("c"),
        cx = cv.getContext("2d");
      let W,
        H,
        tz = "Europe/Warsaw",
        hc = {},
        cht = null,
        pm = null,
        t = 0,
        stars = [],
        p = [];
      let audioCtx = null,
        soundEnabled = true,
        lastSoundTime = {};
      let ambientNodes = [],
        currentAmbient = null,
        masterGain = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          masterGain = audioCtx.createGain();
          masterGain.connect(audioCtx.destination);
          masterGain.gain.value = 0.4;
        }
        if (audioCtx.state === "suspended") audioCtx.resume();
      }

      function startAmbient(type) {
        if (!soundEnabled) return;
        initAudio();
        if (currentAmbient === type) return;
        stopAmbient();
        currentAmbient = type;

        if (type === "fireworks" || type === "newyear") {
          // Fajerwerki - szum t≈Ça + losowe huki
          const noise = createNoise(0.03);
          ambientNodes.push(noise);
          // Losowe eksplozje
          setInterval(() => {
            if (currentAmbient !== type || !soundEnabled) return;
            createBoom();
          }, 800 + Math.random() * 1500);
        } else if (
          type === "christmas" ||
          type === "christmas2" ||
          type === "stnicolas" ||
          type === "advent1" ||
          type === "gaudete"
        ) {
          // Dzwoneczki - ciƒÖg≈Çe delikatne tony
          const freqs = [880, 1109, 1318, 1760];
          freqs.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            osc.type = "sine";
            osc.frequency.value = f;
            lfo.frequency.value = 0.3 + i * 0.1;
            lfoGain.gain.value = 0.015;
            lfo.connect(lfoGain);
            lfoGain.connect(gain.gain);
            gain.gain.value = 0.025;
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            lfo.start();
            ambientNodes.push({
              stop: () => {
                osc.stop();
                lfo.stop();
              },
            });
          });
        } else if (type === "valentine" || type === "sacredheart") {
          // Bicie serca - pulsujƒÖcy bas
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const lfo = audioCtx.createOscillator();
          const lfoGain = audioCtx.createGain();
          osc.type = "sine";
          osc.frequency.value = 55;
          lfo.type = "square";
          lfo.frequency.value = 1.2;
          lfoGain.gain.value = 0.2;
          lfo.connect(lfoGain);
          lfoGain.connect(gain.gain);
          gain.gain.value = 0.15;
          osc.connect(gain);
          gain.connect(masterGain);
          osc.start();
          lfo.start();
          ambientNodes.push({
            stop: () => {
              osc.stop();
              lfo.stop();
            },
          });
        } else if (type === "pentecost" || type === "stjohn") {
          // Ogie≈Ñ - szum + trzaski
          const noise = createNoise(0.06);
          const filter = audioCtx.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.value = 800;
          filter.Q.value = 1;
          noise.node.disconnect();
          noise.node.connect(filter);
          filter.connect(masterGain);
          ambientNodes.push(noise);
          // Trzaski
          const crack = () => {
            if (currentAmbient !== type || !soundEnabled) return;
            const n = audioCtx.createBufferSource();
            const b = audioCtx.createBuffer(
              1,
              audioCtx.sampleRate * 0.05,
              audioCtx.sampleRate
            );
            const d = b.getChannelData(0);
            for (let i = 0; i < d.length; i++)
              d[i] = (Math.random() * 2 - 1) * Math.exp((-i / d.length) * 3);
            n.buffer = b;
            const g = audioCtx.createGain();
            g.gain.value = 0.15;
            n.connect(g);
            g.connect(masterGain);
            n.start();
            setTimeout(crack, 100 + Math.random() * 400);
          };
          setTimeout(crack, 500);
        } else if (
          type === "ascension" ||
          type === "assumption" ||
          type === "innocents" ||
          type === "labor"
        ) {
          // Wiatr - filtrowany szum
          const noise = createNoise(0.12);
          const filter = audioCtx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.value = 400;
          const lfo = audioCtx.createOscillator();
          const lfoGain = audioCtx.createGain();
          lfo.frequency.value = 0.2;
          lfoGain.gain.value = 200;
          lfo.connect(lfoGain);
          lfoGain.connect(filter.frequency);
          noise.node.disconnect();
          noise.node.connect(filter);
          filter.connect(masterGain);
          lfo.start();
          ambientNodes.push(noise, { stop: () => lfo.stop() });
        } else if (
          type === "allsaints" ||
          type === "allsouls" ||
          type === "czestochowa"
        ) {
          // Ch√≥r - akordy z wibrato
          const freqs = [131, 165, 196, 262];
          freqs.forEach((f) => {
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const vib = audioCtx.createOscillator();
            const vibGain = audioCtx.createGain();
            osc.type = "triangle";
            osc2.type = "sine";
            osc.frequency.value = f;
            osc2.frequency.value = f * 1.002;
            vib.frequency.value = 5;
            vibGain.gain.value = 2;
            vib.connect(vibGain);
            vibGain.connect(osc.frequency);
            vibGain.connect(osc2.frequency);
            gain.gain.value = 0.03;
            osc.connect(gain);
            osc2.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc2.start();
            vib.start();
            ambientNodes.push({
              stop: () => {
                osc.stop();
                osc2.stop();
                vib.stop();
              },
            });
          });
        } else if (type === "halloween") {
          // Straszne - niski drone
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const lfo = audioCtx.createOscillator();
          const lfoGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          osc.type = "sawtooth";
          osc2.type = "square";
          osc.frequency.value = 55;
          osc2.frequency.value = 55.5;
          filter.type = "lowpass";
          filter.frequency.value = 200;
          lfo.frequency.value = 0.1;
          lfoGain.gain.value = 100;
          lfo.connect(lfoGain);
          lfoGain.connect(filter.frequency);
          gain.gain.value = 0.08;
          osc.connect(filter);
          osc2.connect(filter);
          filter.connect(gain);
          gain.connect(masterGain);
          osc.start();
          osc2.start();
          lfo.start();
          ambientNodes.push({
            stop: () => {
              osc.stop();
              osc2.stop();
              lfo.stop();
            },
          });
          // Jƒôki
          const moan = () => {
            if (currentAmbient !== type || !soundEnabled) return;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = "sine";
            o.frequency.value = 200 + Math.random() * 100;
            o.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 1);
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 0.3);
            g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            o.connect(g);
            g.connect(masterGain);
            o.start();
            o.stop(audioCtx.currentTime + 1);
            setTimeout(moan, 3000 + Math.random() * 4000);
          };
          setTimeout(moan, 2000);
        } else if (
          type === "palm" ||
          type === "stpatrick" ||
          type === "stbarbara" ||
          type === "corpuschristi"
        ) {
          // Szelest li≈õci
          const noise = createNoise(0.04);
          const filter = audioCtx.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.value = 3000;
          filter.Q.value = 2;
          const lfo = audioCtx.createOscillator();
          const lfoGain = audioCtx.createGain();
          lfo.frequency.value = 0.5;
          lfoGain.gain.value = 0.02;
          lfo.connect(lfoGain);
          lfoGain.connect(noise.gain.gain);
          noise.node.disconnect();
          noise.node.connect(filter);
          filter.connect(masterGain);
          lfo.start();
          ambientNodes.push(noise, { stop: () => lfo.stop() });
        } else if (type === "baptism") {
          // Woda - szum + kapanie
          const noise = createNoise(0.08);
          const filter = audioCtx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.value = 600;
          noise.node.disconnect();
          noise.node.connect(filter);
          filter.connect(masterGain);
          ambientNodes.push(noise);
          // Kapanie
          const drip = () => {
            if (currentAmbient !== type || !soundEnabled) return;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.frequency.value = 1800;
            o.frequency.exponentialRampToValueAtTime(
              600,
              audioCtx.currentTime + 0.1
            );
            g.gain.setValueAtTime(0.08, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.15
            );
            o.connect(g);
            g.connect(masterGain);
            o.start();
            o.stop(audioCtx.currentTime + 0.15);
            setTimeout(drip, 500 + Math.random() * 1500);
          };
          setTimeout(drip, 1000);
        } else if (
          type === "epiphany" ||
          type === "transfig" ||
          type === "nativitymary" ||
          type === "holyfamily"
        ) {
          // Magiczne b≈Çyski - wysokie tony
          const sparkle = () => {
            if (currentAmbient !== type || !soundEnabled) return;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.frequency.value = 2000 + Math.random() * 2000;
            g.gain.setValueAtTime(0.04, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.3
            );
            o.connect(g);
            g.connect(masterGain);
            o.start();
            o.stop(audioCtx.currentTime + 0.3);
            setTimeout(sparkle, 200 + Math.random() * 600);
          };
          sparkle();
          // Pad w tle
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = "sine";
          osc.frequency.value = 440;
          gain.gain.value = 0.02;
          osc.connect(gain);
          gain.connect(masterGain);
          osc.start();
          ambientNodes.push({ stop: () => osc.stop() });
        } else if (
          type === "goodfriday" ||
          type === "holycross" ||
          type === "ashwed"
        ) {
          // Cisza + powolny dzwon
          const bell = () => {
            if (currentAmbient !== type || !soundEnabled) return;
            const o = audioCtx.createOscillator();
            const o2 = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.frequency.value = 220;
            o2.frequency.value = 440;
            g.gain.setValueAtTime(0.08, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 4
            );
            o.connect(g);
            o2.connect(g);
            g.connect(masterGain);
            o.start();
            o2.start();
            o.stop(audioCtx.currentTime + 4);
            o2.stop(audioCtx.currentTime + 4);
            setTimeout(bell, 5000);
          };
          bell();
        } else {
          // Domy≈õlne - cichy pad
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = "sine";
          osc.frequency.value = 220;
          gain.gain.value = 0.015;
          osc.connect(gain);
          gain.connect(masterGain);
          osc.start();
          ambientNodes.push({ stop: () => osc.stop() });
        }
      }

      function createNoise(volume) {
        const bufferSize = 2 * audioCtx.sampleRate;
        const buffer = audioCtx.createBuffer(
          1,
          bufferSize,
          audioCtx.sampleRate
        );
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const node = audioCtx.createBufferSource();
        node.buffer = buffer;
        node.loop = true;
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        node.connect(gain);
        gain.connect(masterGain);
        node.start();
        return { node, gain, stop: () => node.stop() };
      }

      function createBoom() {
        if (!audioCtx || !soundEnabled) return;
        const ct = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const noise = audioCtx.createBufferSource();
        const buf = audioCtx.createBuffer(
          1,
          audioCtx.sampleRate * 0.3,
          audioCtx.sampleRate
        );
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++)
          d[i] = (Math.random() * 2 - 1) * Math.exp((-i / d.length) * 3);
        noise.buffer = buf;
        const g1 = audioCtx.createGain();
        const g2 = audioCtx.createGain();
        osc.frequency.value = 60;
        g1.gain.setValueAtTime(0.15, ct);
        g1.gain.exponentialRampToValueAtTime(0.001, ct + 0.4);
        g2.gain.setValueAtTime(0.1, ct);
        g2.gain.exponentialRampToValueAtTime(0.001, ct + 0.3);
        osc.connect(g1);
        noise.connect(g2);
        g1.connect(masterGain);
        g2.connect(masterGain);
        osc.start();
        noise.start();
        osc.stop(ct + 0.4);
        noise.stop(ct + 0.3);
      }

      function stopAmbient() {
        currentAmbient = null;
        ambientNodes.forEach((n) => {
          try {
            if (n.stop) n.stop();
          } catch (e) {}
        });
        ambientNodes = [];
      }

      function playSound(type, force = false) {
        if (!soundEnabled) return;
        if (!audioCtx) initAudio();
        if (!audioCtx) return;
        if (audioCtx.state === "suspended") audioCtx.resume();
        // Limit czƒôstotliwo≈õci d≈∫wiƒôk√≥w
        const now = Date.now();
        if (!force && lastSoundTime[type] && now - lastSoundTime[type] < 300)
          return;
        lastSoundTime[type] = now;

        const ct = audioCtx.currentTime;

        if (type === "launch") {
          // ≈öwist rakiety - realistyczny
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          osc.connect(gain);
          osc2.connect(gain);
          gain.connect(filter);
          filter.connect(audioCtx.destination);
          osc.type = "sawtooth";
          osc2.type = "triangle";
          filter.type = "bandpass";
          filter.frequency.setValueAtTime(1000, ct);
          filter.frequency.exponentialRampToValueAtTime(3000, ct + 0.8);
          filter.Q.value = 2;
          osc.frequency.setValueAtTime(150, ct);
          osc.frequency.exponentialRampToValueAtTime(800, ct + 0.8);
          osc2.frequency.setValueAtTime(200, ct);
          osc2.frequency.exponentialRampToValueAtTime(1200, ct + 0.8);
          gain.gain.setValueAtTime(0.06, ct);
          gain.gain.linearRampToValueAtTime(0.12, ct + 0.2);
          gain.gain.exponentialRampToValueAtTime(0.001, ct + 0.8);
          osc.start(ct);
          osc.stop(ct + 0.8);
          osc2.start(ct);
          osc2.stop(ct + 0.8);
        } else if (type === "explode") {
          // Eksplozja - g≈Çƒôboki boom z trzaskami
          const bufferSize = audioCtx.sampleRate * 0.8;
          const buffer = audioCtx.createBuffer(
            2,
            bufferSize,
            audioCtx.sampleRate
          );
          for (let ch = 0; ch < 2; ch++) {
            const data = buffer.getChannelData(ch);
            for (let i = 0; i < bufferSize; i++) {
              const env = Math.pow(1 - i / bufferSize, 1.2);
              const boom =
                Math.sin((i / audioCtx.sampleRate) * 80 * Math.PI * 2) *
                Math.exp((-i / audioCtx.sampleRate) * 8);
              data[i] = ((Math.random() * 2 - 1) * 0.6 + boom * 0.4) * env;
            }
          }
          const noise = audioCtx.createBufferSource();
          noise.buffer = buffer;
          const gain = audioCtx.createGain();
          const lpf = audioCtx.createBiquadFilter();
          const hpf = audioCtx.createBiquadFilter();
          lpf.type = "lowpass";
          lpf.frequency.setValueAtTime(4000, ct);
          lpf.frequency.exponentialRampToValueAtTime(300, ct + 0.6);
          hpf.type = "highpass";
          hpf.frequency.value = 40;
          noise.connect(lpf);
          lpf.connect(hpf);
          hpf.connect(gain);
          gain.connect(audioCtx.destination);
          gain.gain.setValueAtTime(0.35, ct);
          gain.gain.exponentialRampToValueAtTime(0.001, ct + 0.8);
          noise.start(ct);
          noise.stop(ct + 0.8);
        } else if (type === "bells") {
          // Dzwony ko≈õcielne - realistyczne z pog≈Çosem
          const freqs = [523, 659, 784, 1047];
          freqs.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const delay = audioCtx.createDelay();
            const delayGain = audioCtx.createGain();
            osc.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);
            gain.connect(delay);
            delay.connect(delayGain);
            delayGain.connect(audioCtx.destination);
            delay.delayTime.value = 0.15;
            delayGain.gain.value = 0.3;
            osc.type = "sine";
            osc2.type = "sine";
            osc.frequency.value = f;
            osc2.frequency.value = f * 2.01;
            const start = ct + i * 0.4;
            gain.gain.setValueAtTime(0, start);
            gain.gain.linearRampToValueAtTime(0.08, start + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, start + 2.5);
            osc.start(start);
            osc.stop(start + 2.5);
            osc2.start(start);
            osc2.stop(start + 2.5);
          });
        } else if (type === "chime") {
          // Delikatny dzwonek kryszta≈Çowy
          const freqs = [1760, 2217, 2637];
          freqs.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = "sine";
            osc.frequency.value = f;
            const start = ct + i * 0.08;
            gain.gain.setValueAtTime(0.06, start);
            gain.gain.exponentialRampToValueAtTime(0.001, start + 1.2);
            osc.start(start);
            osc.stop(start + 1.2);
          });
        } else if (type === "whoosh") {
          // Wiatr/unoszenie - miƒôkki szum
          const bufferSize = audioCtx.sampleRate * 1.2;
          const buffer = audioCtx.createBuffer(
            2,
            bufferSize,
            audioCtx.sampleRate
          );
          for (let ch = 0; ch < 2; ch++) {
            const data = buffer.getChannelData(ch);
            for (let i = 0; i < bufferSize; i++) {
              const env = Math.sin((i / bufferSize) * Math.PI);
              data[i] = (Math.random() * 2 - 1) * env * 0.15;
            }
          }
          const noise = audioCtx.createBufferSource();
          noise.buffer = buffer;
          const filter = audioCtx.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.value = 600;
          filter.Q.value = 0.5;
          const gain = audioCtx.createGain();
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          gain.gain.setValueAtTime(0.2, ct);
          noise.start(ct);
          noise.stop(ct + 1.2);
        } else if (type === "sparkle") {
          // Magiczny b≈Çysk
          for (let i = 0; i < 5; i++) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = "sine";
            const f = 2500 + Math.random() * 2000;
            osc.frequency.setValueAtTime(f, ct + i * 0.06);
            osc.frequency.exponentialRampToValueAtTime(
              f * 0.7,
              ct + i * 0.06 + 0.15
            );
            gain.gain.setValueAtTime(0.04, ct + i * 0.06);
            gain.gain.exponentialRampToValueAtTime(0.001, ct + i * 0.06 + 0.2);
            osc.start(ct + i * 0.06);
            osc.stop(ct + i * 0.06 + 0.2);
          }
        } else if (type === "heartbeat") {
          // Realistyczne bicie serca
          [0, 0.18].forEach((delay, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            filter.type = "lowpass";
            filter.frequency.value = 150;
            osc.type = "sine";
            osc.frequency.setValueAtTime(i === 0 ? 55 : 45, ct + delay);
            const vol = i === 0 ? 0.25 : 0.18;
            gain.gain.setValueAtTime(vol, ct + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, ct + delay + 0.12);
            osc.start(ct + delay);
            osc.stop(ct + delay + 0.15);
          });
        } else if (type === "drop") {
          // Kropla wody - plink
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          filter.type = "bandpass";
          filter.frequency.value = 2000;
          filter.Q.value = 5;
          osc.type = "sine";
          osc.frequency.setValueAtTime(2400, ct);
          osc.frequency.exponentialRampToValueAtTime(800, ct + 0.08);
          gain.gain.setValueAtTime(0.12, ct);
          gain.gain.exponentialRampToValueAtTime(0.001, ct + 0.25);
          osc.start(ct);
          osc.stop(ct + 0.25);
        } else if (type === "crackle") {
          // Trzask ognia
          for (let i = 0; i < 3; i++) {
            const bufferSize = audioCtx.sampleRate * 0.08;
            const buffer = audioCtx.createBuffer(
              1,
              bufferSize,
              audioCtx.sampleRate
            );
            const data = buffer.getChannelData(0);
            for (let j = 0; j < bufferSize; j++)
              data[j] =
                (Math.random() * 2 - 1) * Math.pow(1 - j / bufferSize, 4);
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            const hpf = audioCtx.createBiquadFilter();
            hpf.type = "highpass";
            hpf.frequency.value = 800 + Math.random() * 1000;
            noise.connect(hpf);
            hpf.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.08, ct + i * 0.1);
            noise.start(ct + i * 0.1);
            noise.stop(ct + i * 0.1 + 0.08);
          }
        } else if (type === "bounce") {
          // Odbicie - sprƒô≈ºysty d≈∫wiƒôk
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.type = "sine";
          osc.frequency.setValueAtTime(400, ct);
          osc.frequency.exponentialRampToValueAtTime(120, ct + 0.12);
          gain.gain.setValueAtTime(0.15, ct);
          gain.gain.exponentialRampToValueAtTime(0.001, ct + 0.18);
          osc.start(ct);
          osc.stop(ct + 0.18);
        } else if (type === "rustle") {
          // Szelest li≈õci - naturalistyczny
          const bufferSize = audioCtx.sampleRate * 0.4;
          const buffer = audioCtx.createBuffer(
            2,
            bufferSize,
            audioCtx.sampleRate
          );
          for (let ch = 0; ch < 2; ch++) {
            const data = buffer.getChannelData(ch);
            for (let i = 0; i < bufferSize; i++) {
              const env = Math.sin((i / bufferSize) * Math.PI) * 0.8;
              data[i] =
                (Math.random() * 2 - 1) *
                env *
                (0.5 + Math.random() * 0.5) *
                0.1;
            }
          }
          const noise = audioCtx.createBufferSource();
          noise.buffer = buffer;
          const filter = audioCtx.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.value = 4000;
          filter.Q.value = 1;
          const gain = audioCtx.createGain();
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          gain.gain.setValueAtTime(0.15, ct);
          noise.start(ct);
          noise.stop(ct + 0.4);
        } else if (type === "choir") {
          // Ch√≥r - akordy z wibrato
          const notes = [262, 330, 392, 523];
          notes.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const vib = audioCtx.createOscillator();
            const vibGain = audioCtx.createGain();
            osc.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);
            vib.connect(vibGain);
            vibGain.connect(osc.frequency);
            vibGain.connect(osc2.frequency);
            vib.frequency.value = 5.5;
            vibGain.gain.value = 4;
            osc.type = "triangle";
            osc2.type = "sine";
            osc.frequency.value = f;
            osc2.frequency.value = f * 1.002;
            gain.gain.setValueAtTime(0, ct);
            gain.gain.linearRampToValueAtTime(0.04, ct + 0.5);
            gain.gain.linearRampToValueAtTime(0.04, ct + 2);
            gain.gain.exponentialRampToValueAtTime(0.001, ct + 3);
            osc.start(ct);
            osc.stop(ct + 3);
            osc2.start(ct);
            osc2.stop(ct + 3);
            vib.start(ct);
            vib.stop(ct + 3);
          });
        } else if (type === "spooky") {
          // Straszny d≈∫wiƒôk - niski drone z modulacjƒÖ
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const lfo = audioCtx.createOscillator();
          const lfoGain = audioCtx.createGain();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          osc.connect(filter);
          osc2.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          lfo.connect(lfoGain);
          lfoGain.connect(filter.frequency);
          filter.type = "lowpass";
          filter.frequency.value = 400;
          lfo.frequency.value = 0.5;
          lfoGain.gain.value = 200;
          osc.type = "sawtooth";
          osc2.type = "square";
          osc.frequency.value = 80;
          osc2.frequency.value = 81;
          gain.gain.setValueAtTime(0, ct);
          gain.gain.linearRampToValueAtTime(0.1, ct + 0.3);
          gain.gain.linearRampToValueAtTime(0.08, ct + 1.2);
          gain.gain.exponentialRampToValueAtTime(0.001, ct + 1.8);
          osc.start(ct);
          osc.stop(ct + 1.8);
          osc2.start(ct);
          osc2.stop(ct + 1.8);
          lfo.start(ct);
          lfo.stop(ct + 1.8);
        } else if (type === "fanfare") {
          // Fanfara trƒÖbkowa
          const melody = [392, 392, 523, 392, 523, 659];
          melody.forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = "sawtooth";
            osc2.type = "square";
            osc.frequency.value = f;
            osc2.frequency.value = f * 2;
            const start = ct + i * 0.15;
            const dur = i === melody.length - 1 ? 0.5 : 0.12;
            gain.gain.setValueAtTime(0, start);
            gain.gain.linearRampToValueAtTime(0.06, start + 0.02);
            gain.gain.linearRampToValueAtTime(0.05, start + dur * 0.8);
            gain.gain.exponentialRampToValueAtTime(0.001, start + dur);
            osc.start(start);
            osc.stop(start + dur);
            osc2.start(start);
            osc2.stop(start + dur);
          });
        }
      }

      // Mapowanie typ√≥w ≈õwiƒÖt na d≈∫wiƒôki
      const soundMap = {
        fireworks: "explode",
        newyear: "explode",
        valentine: "heartbeat",
        sacredheart: "heartbeat",
        easter: "bounce",
        eastermon: "bounce",
        christmas: "bells",
        christmas2: "bells",
        stnicolas: "bells",
        epiphany: "sparkle",
        nativitymary: "sparkle",
        holyfamily: "sparkle",
        transfig: "sparkle",
        pentecost: "crackle",
        stjohn: "crackle",
        ascension: "whoosh",
        assumption: "whoosh",
        innocents: "whoosh",
        halloween: "spooky",
        allsaints: "choir",
        allsouls: "choir",
        baptism: "drop",
        palm: "rustle",
        stbarbara: "rustle",
        stpatrick: "rustle",
        corpuschristi: "rustle",
        constitution: "fanfare",
        independence: "fanfare",
        christking: "fanfare",
        goodfriday: "bells",
        holycross: "bells",
        ashwed: "bells",
        presentation: "chime",
        annunciation: "chime",
        immaculate: "chime",
        rosary: "chime",
        holythurs: "chime",
        holysat: "chime",
        advent1: "chime",
        gaudete: "chime",
        stlucy: "chime",
        standrew: "chime",
        peterpoul: "chime",
        stmartin: "chime",
        labor: "whoosh",
        czestochowa: "choir",
      };

      document.addEventListener("click", () => initAudio(), { once: true });
      document.addEventListener("touchstart", () => initAudio(), {
        once: true,
      });

      function rs() {
        W = cv.width = innerWidth;
        H = cv.height = innerHeight;
        stars = [];
        for (let i = 0; i < 150; i++)
          stars.push({
            x: Math.random() * W,
            y: Math.random() * H * 0.7,
            s: Math.random() * 2 + 0.5,
            sp: Math.random() * 2 + 1,
            o: Math.random() * Math.PI * 2,
          });
      }
      rs();
      onresize = rs;

      // ≈öwiƒôta z emoji i typem animacji: fall=spada, rise=unosi, bounce=skacze, center=centrum, sway=ko≈Çysze, fireworks=fajerwerki, stars=migajƒÖce
      const hs = [
        {
          n: "Sylwester / Nowy Rok",
          m: 12,
          d: 31,
          t: "newyear",
          sp: 1,
          a: "fireworks",
          e: "üéÜ",
          c: ["#FFD700", "#FF6B6B", "#4ECDC4"],
        },
        {
          n: "Trzech Kr√≥li",
          m: 1,
          d: 6,
          t: "epiphany",
          a: "stars",
          e: "‚≠ê",
          c: ["#FFD700", "#8B4513", "#4169E1"],
        },
        {
          n: "Ofiarowanie Pa≈Ñskie",
          m: 2,
          d: 2,
          t: "presentation",
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#FFFFFF", "#FFD700", "#87CEEB"],
        },
        {
          n: "Walentynki",
          m: 2,
          d: 14,
          t: "valentine",
          a: "rise",
          e: "‚ù§Ô∏è",
          c: ["#FF69B4", "#FF1493", "#DC143C"],
        },
        {
          n: "≈öroda Popielcowa",
          m: 0,
          d: 0,
          t: "ashwed",
          mv: 1,
          a: "fall",
          e: "‚úùÔ∏è",
          c: ["#808080", "#4B0082", "#2F4F4F"],
        },
        {
          n: "≈öw. Patryka",
          m: 3,
          d: 17,
          t: "stpatrick",
          a: "fall",
          e: "‚òòÔ∏è",
          c: ["#228B22", "#32CD32", "#00FF00"],
        },
        {
          n: "Zwiastowanie NMP",
          m: 3,
          d: 25,
          t: "annunciation",
          a: "glow",
          e: "üå∑",
          c: ["#87CEEB", "#FFFFFF", "#FFD700"],
        },
        {
          n: "Niedziela Palmowa",
          m: 0,
          d: 0,
          t: "palm",
          mv: 1,
          a: "sway",
          e: "üåø",
          c: ["#228B22", "#8B4513", "#FFD700"],
        },
        {
          n: "Wielki Czwartek",
          m: 0,
          d: 0,
          t: "holythurs",
          mv: 1,
          a: "glow",
          e: "üçû",
          c: ["#8B0000", "#FFD700", "#FFFFFF"],
        },
        {
          n: "Wielki PiƒÖtek",
          m: 0,
          d: 0,
          t: "goodfriday",
          mv: 1,
          a: "center",
          e: "‚úùÔ∏è",
          c: ["#000000", "#8B0000", "#4B0082"],
        },
        {
          n: "Wielka Sobota",
          m: 0,
          d: 0,
          t: "holysat",
          mv: 1,
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#4B0082", "#8B0000", "#FFFFFF"],
        },
        {
          n: "Wielkanoc",
          m: 0,
          d: 0,
          t: "easter",
          mv: 1,
          a: "bounce",
          e: "ü•ö",
          c: ["#FFD700", "#90EE90", "#FF69B4"],
        },
        {
          n: "Poniedzia≈Çek Wielkanocny",
          m: 0,
          d: 0,
          t: "eastermon",
          mv: 1,
          a: "bounce",
          e: "üê£",
          c: ["#90EE90", "#FFD700", "#87CEEB"],
        },
        {
          n: "≈öwiƒôto Pracy",
          m: 5,
          d: 1,
          t: "labor",
          a: "fall",
          e: "üå∏",
          c: ["#FF0000", "#FFFFFF", "#FFD700"],
        },
        {
          n: "Konstytucja 3 Maja",
          m: 5,
          d: 3,
          t: "constitution",
          a: "sway",
          e: "üáµüá±",
          c: ["#FFFFFF", "#DC143C", "#FFD700"],
        },
        {
          n: "WniebowstƒÖpienie",
          m: 0,
          d: 0,
          t: "ascension",
          mv: 1,
          a: "rise",
          e: "‚òÅÔ∏è",
          c: ["#87CEEB", "#FFD700", "#FFFFFF"],
        },
        {
          n: "Zes≈Çanie Ducha ≈öw.",
          m: 0,
          d: 0,
          t: "pentecost",
          mv: 1,
          a: "rise",
          e: "üî•",
          c: ["#FF0000", "#FFD700", "#FF4500"],
        },
        {
          n: "Bo≈ºe Cia≈Ço",
          m: 0,
          d: 0,
          t: "corpuschristi",
          mv: 1,
          a: "fall",
          e: "üå∏",
          c: ["#FFD700", "#FFFFFF", "#8B0000"],
        },
        {
          n: "Serca Jezusa",
          m: 0,
          d: 0,
          t: "sacredheart",
          mv: 1,
          a: "rise",
          e: "‚ù§Ô∏è",
          c: ["#DC143C", "#FFD700", "#FFFFFF"],
        },
        {
          n: "≈öw. Jana Chrzciciela",
          m: 6,
          d: 24,
          t: "stjohn",
          a: "rise",
          e: "üî•",
          c: ["#228B22", "#FFD700", "#FF4500"],
        },
        {
          n: "≈öw. Piotra i Paw≈Ça",
          m: 6,
          d: 29,
          t: "peterpoul",
          a: "glow",
          e: "üîë",
          c: ["#FFD700", "#8B0000", "#FFFFFF"],
        },
        {
          n: "Przemienienie Pa≈Ñskie",
          m: 8,
          d: 6,
          t: "transfig",
          a: "rays",
          e: "‚ú®",
          c: ["#FFFFFF", "#FFD700", "#87CEEB"],
        },
        {
          n: "Wniebowziƒôcie NMP",
          m: 8,
          d: 15,
          t: "assumption",
          a: "rise",
          e: "üåπ",
          c: ["#87CEEB", "#FFFFFF", "#FFD700"],
        },
        {
          n: "MB Czƒôstochowskiej",
          m: 8,
          d: 26,
          t: "czestochowa",
          a: "glow",
          e: "üëë",
          c: ["#000000", "#FFD700", "#4169E1"],
        },
        {
          n: "Narodzenie NMP",
          m: 9,
          d: 8,
          t: "nativitymary",
          a: "stars",
          e: "‚≠ê",
          c: ["#87CEEB", "#FFFFFF", "#FFB6C1"],
        },
        {
          n: "Podwy≈ºszenie Krzy≈ºa",
          m: 9,
          d: 14,
          t: "holycross",
          a: "center",
          e: "‚úùÔ∏è",
          c: ["#8B4513", "#8B0000", "#FFD700"],
        },
        {
          n: "MB R√≥≈ºa≈Ñcowej",
          m: 10,
          d: 7,
          t: "rosary",
          a: "fall",
          e: "üìø",
          c: ["#4169E1", "#FFFFFF", "#FFD700"],
        },
        {
          n: "Halloween",
          m: 10,
          d: 31,
          t: "halloween",
          a: "bounce",
          e: "üéÉ",
          c: ["#FF6600", "#000000", "#800080"],
        },
        {
          n: "Wszystkich ≈öwiƒôtych",
          m: 11,
          d: 1,
          t: "allsaints",
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#FFD700", "#FFFFFF", "#FF6600"],
        },
        {
          n: "Dzie≈Ñ Zaduszny",
          m: 11,
          d: 2,
          t: "allsouls",
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#4B0082", "#000000", "#FF6600"],
        },
        {
          n: "≈öw. Marcina",
          m: 11,
          d: 11,
          t: "stmartin",
          a: "rise",
          e: "üèÆ",
          c: ["#FFD700", "#8B4513", "#FFFFFF"],
        },
        {
          n: "Niepodleg≈Ço≈õci",
          m: 11,
          d: 11,
          t: "independence",
          a: "sway",
          e: "üáµüá±",
          c: ["#FFFFFF", "#DC143C", "#FFD700"],
        },
        {
          n: "Chrystusa Kr√≥la",
          m: 0,
          d: 0,
          t: "christking",
          mv: 1,
          a: "glow",
          e: "üëë",
          c: ["#FFD700", "#8B0000", "#FFFFFF"],
        },
        {
          n: "≈öw. Andrzeja",
          m: 11,
          d: 30,
          t: "standrew",
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#4169E1", "#FFFFFF", "#FFD700"],
        },
        {
          n: "Adwent",
          m: 0,
          d: 0,
          t: "advent1",
          mv: 1,
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#4B0082", "#FFD700", "#FFFFFF"],
        },
        {
          n: "≈öw. Barbary",
          m: 12,
          d: 4,
          t: "stbarbara",
          a: "sway",
          e: "üåø",
          c: ["#DC143C", "#FFD700", "#FFFFFF"],
        },
        {
          n: "≈öw. Miko≈Çaja",
          m: 12,
          d: 6,
          t: "stnicolas",
          a: "fall",
          e: "üéÅ",
          c: ["#DC143C", "#FFFFFF", "#228B22"],
        },
        {
          n: "Niepokalane Poczƒôcie",
          m: 12,
          d: 8,
          t: "immaculate",
          a: "glow",
          e: "üå∑",
          c: ["#87CEEB", "#FFFFFF", "#FFD700"],
        },
        {
          n: "Gaudete",
          m: 0,
          d: 0,
          t: "gaudete",
          mv: 1,
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#FFB6C1", "#4B0082", "#FFD700"],
        },
        {
          n: "≈öw. ≈Åucji",
          m: 12,
          d: 13,
          t: "stlucy",
          a: "glow",
          e: "üïØÔ∏è",
          c: ["#FFFFFF", "#DC143C", "#FFD700"],
        },
        {
          n: "Wigilia",
          m: 12,
          d: 24,
          t: "christmas",
          a: "fall",
          e: "‚ùÑÔ∏è",
          c: ["#DC143C", "#228B22", "#FFD700"],
        },
        {
          n: "Bo≈ºe Narodzenie",
          m: 12,
          d: 25,
          t: "christmas2",
          a: "fall",
          e: "üéÑ",
          c: ["#DC143C", "#228B22", "#FFD700"],
        },
        {
          n: "≈öw. Szczepana",
          m: 12,
          d: 26,
          t: "ststephen",
          a: "fall",
          e: "‚ùÑÔ∏è",
          c: ["#DC143C", "#FFFFFF", "#FFD700"],
        },
        {
          n: "≈öwiƒôtej Rodziny",
          m: 0,
          d: 0,
          t: "holyfamily",
          mv: 1,
          a: "stars",
          e: "‚≠ê",
          c: ["#8B4513", "#87CEEB", "#FFD700"],
        },
        {
          n: "M≈Çodziank√≥w",
          m: 12,
          d: 28,
          t: "innocents",
          a: "rise",
          e: "üëº",
          c: ["#FF69B4", "#FFFFFF", "#DC143C"],
        },
        {
          n: "Chrzest Pa≈Ñski",
          m: 0,
          d: 0,
          t: "baptism",
          mv: 1,
          a: "fall",
          e: "üíß",
          c: ["#87CEEB", "#FFFFFF", "#FFD700"],
        },
      ];

      function getEaster(y) {
        const a = y % 19,
          b = Math.floor(y / 100),
          c = y % 100,
          d = Math.floor(b / 4),
          e = b % 4,
          f = Math.floor((b + 8) / 25),
          g = Math.floor((b - f + 1) / 3),
          h = (19 * a + b - d - g + 15) % 30,
          i = Math.floor(c / 4),
          k = c % 4,
          l = (32 + 2 * e + 2 * i - h - k) % 7,
          m = Math.floor((a + 11 * h + 22 * l) / 451);
        return new Date(
          y,
          Math.floor((h + l - 7 * m + 114) / 31) - 1,
          ((h + l - 7 * m + 114) % 31) + 1
        );
      }
      function getMov(y) {
        const e = getEaster(y),
          d = {};
        d.ashwed = new Date(e);
        d.ashwed.setDate(e.getDate() - 46);
        d.palm = new Date(e);
        d.palm.setDate(e.getDate() - 7);
        d.holythurs = new Date(e);
        d.holythurs.setDate(e.getDate() - 3);
        d.goodfriday = new Date(e);
        d.goodfriday.setDate(e.getDate() - 2);
        d.holysat = new Date(e);
        d.holysat.setDate(e.getDate() - 1);
        d.easter = e;
        d.eastermon = new Date(e);
        d.eastermon.setDate(e.getDate() + 1);
        d.ascension = new Date(e);
        d.ascension.setDate(e.getDate() + 39);
        d.pentecost = new Date(e);
        d.pentecost.setDate(e.getDate() + 49);
        d.corpuschristi = new Date(e);
        d.corpuschristi.setDate(e.getDate() + 60);
        d.sacredheart = new Date(e);
        d.sacredheart.setDate(e.getDate() + 68);
        const x = new Date(y, 11, 25),
          a = new Date(x);
        a.setDate(x.getDate() - 21 - ((x.getDay() + 1) % 7));
        d.advent1 = a;
        d.christking = new Date(a);
        d.christking.setDate(a.getDate() - 7);
        d.gaudete = new Date(a);
        d.gaudete.setDate(a.getDate() + 14);
        d.holyfamily =
          x.getDay() === 0
            ? new Date(y, 11, 30)
            : new Date(y, 11, 25 + ((7 - x.getDay()) % 7));
        const ep = new Date(y, 0, 6);
        d.baptism =
          ep.getDay() === 0
            ? new Date(y, 0, 7)
            : new Date(y, 0, 6 + ((7 - ep.getDay()) % 7));
        return d;
      }
      function getCur(dt) {
        const y = dt.getFullYear(),
          m = dt.getMonth() + 1,
          d = dt.getDate(),
          h = dt.getHours() + dt.getMinutes() / 60,
          mv = getMov(y);
        for (const x of hs) {
          if (x.mv) {
            const md = mv[x.t];
            if (md && md.getMonth() + 1 === m && md.getDate() === d) return x;
          } else if (x.sp && x.m === 12 && x.d === 31) {
            if ((m === 12 && d === 31) || (m === 1 && d === 1 && h <= 3.5))
              return x;
          } else if (x.m === m && x.d === d) return x;
        }
        return null;
      }
      function getNext(dt) {
        const y = dt.getFullYear(),
          mv = getMov(y),
          mvn = getMov(y + 1);
        let cl = null,
          cd = null;
        for (const x of hs) {
          let hd;
          if (x.mv) {
            hd = mv[x.t];
            if (!hd || hd <= dt) hd = mvn[x.t];
          } else {
            hd = new Date(y, x.m - 1, x.d);
            if (hd <= dt) hd = new Date(y + 1, x.m - 1, x.d);
          }
          if (hd && (!cd || hd < cd)) {
            cd = hd;
            cl = { ...x, date: hd };
          }
        }
        return cl;
      }
      function getSun(dt, lat = 52.23) {
        const h = dt.getHours() + dt.getMinutes() / 60 + dt.getSeconds() / 3600,
          doy = Math.floor((dt - new Date(dt.getFullYear(), 0, 0)) / 864e5),
          dec = -23.45 * Math.cos(((360 / 365) * (doy + 10) * Math.PI) / 180),
          ha = 15 * (h - 12),
          lr = (lat * Math.PI) / 180,
          dr = (dec * Math.PI) / 180,
          hr = (ha * Math.PI) / 180;
        return {
          alt:
            (Math.asin(
              Math.sin(lr) * Math.sin(dr) +
                Math.cos(lr) * Math.cos(dr) * Math.cos(hr)
            ) *
              180) /
            Math.PI,
          az:
            (Math.atan2(
              Math.sin(hr),
              Math.cos(hr) * Math.sin(lr) - Math.tan(dr) * Math.cos(lr)
            ) *
              180) /
              Math.PI +
            180,
        };
      }
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      function lc(c1, c2, t) {
        const r1 = parseInt(c1.slice(1, 3), 16),
          g1 = parseInt(c1.slice(3, 5), 16),
          b1 = parseInt(c1.slice(5, 7), 16),
          r2 = parseInt(c2.slice(1, 3), 16),
          g2 = parseInt(c2.slice(3, 5), 16),
          b2 = parseInt(c2.slice(5, 7), 16);
        return `rgb(${Math.round(lerp(r1, r2, t))},${Math.round(
          lerp(g1, g2, t)
        )},${Math.round(lerp(b1, b2, t))})`;
      }
      function gc(h) {
        return hc[h.t] || h.c;
      }

      function initP(h) {
        p = [];
        if (!h) return;
        const c = gc(h);
        for (let i = 0; i < 40; i++) {
          const pp = {
            x: Math.random() * W,
            y: Math.random() * H,
            vx: 0,
            vy: 0,
            s: 30 + Math.random() * 30,
            e: h.e,
            c: c[i % 3],
            ph: Math.random() * Math.PI * 2,
            sp: 0.5 + Math.random(),
            r: Math.random() * Math.PI * 2,
            rs: (Math.random() - 0.5) * 0.02,
            life: 1,
          };
          switch (h.a) {
            case "fall":
              pp.y = -50 - Math.random() * 200;
              pp.vy = 0.5 + Math.random();
              break;
            case "rise":
              pp.y = H + 50 + Math.random() * 100;
              pp.vy = -(0.5 + Math.random());
              break;
            case "bounce":
              pp.baseY = H * 0.75;
              pp.y = pp.baseY;
              pp.x = (i / 40) * W * 0.9 + W * 0.05;
              break;
            case "sway":
              pp.baseX = pp.x;
              pp.y = H * 0.7;
              break;
            case "center":
              pp.x = W / 2;
              pp.y = H * 0.4;
              pp.s = Math.min(W, H) * 0.25;
              break;
            case "glow":
              pp.y = H * 0.65 + Math.random() * H * 0.2;
              break;
            case "stars":
              pp.y = Math.random() * H * 0.6;
              pp.tw = Math.random() * Math.PI * 2;
              break;
            case "rays":
              pp.x = W / 2;
              pp.y = H * 0.35;
              pp.angle = (i / 40) * Math.PI * 2;
              pp.s = 150;
              break;
            case "fireworks":
              pp.life = 0;
              pp.expl = false;
              break;
          }
          p.push(pp);
        }
      }

      function updP(h) {
        if (!h) return;
        const c = gc(h);
        const snd = soundMap[h.t];
        for (let i = 0; i < p.length; i++) {
          const pp = p[i];
          switch (h.a) {
            case "fall":
              pp.x += Math.sin(t * 2 + pp.ph) * 0.5;
              pp.y += pp.vy;
              pp.r += pp.rs;
              if (pp.y > H + 50) {
                pp.y = -50;
                pp.x = Math.random() * W;
                if (i === 0 && snd) playSound(snd);
              }
              drawShape(pp, h.t, c);
              break;
            case "rise":
              pp.x += Math.sin(t + pp.ph) * 0.5;
              pp.y += pp.vy;
              if (pp.y < -50) {
                pp.y = H + 50;
                pp.x = Math.random() * W;
                if (i === 0 && snd) playSound(snd);
              }
              drawShape(pp, h.t, c);
              break;
            case "bounce":
              const prevY = pp.y;
              pp.y = pp.baseY - Math.abs(Math.sin(t * pp.sp + pp.ph)) * 40;
              if (
                i === 0 &&
                prevY < pp.baseY - 35 &&
                pp.y >= pp.baseY - 35 &&
                snd
              )
                playSound(snd);
              drawShape(pp, h.t, c);
              break;
            case "sway":
              pp.x = pp.baseX + Math.sin(t * 0.5 + pp.ph) * 30;
              if (i === 0 && Math.abs(Math.sin(t * 0.5 + pp.ph)) < 0.02 && snd)
                playSound(snd);
              drawShape(pp, h.t, c);
              break;
            case "center":
              if (i === 0) drawShape(pp, h.t, c);
              break;
            case "glow":
              if (i === 0 && Math.sin(t * 3 + pp.ph) > 0.98 && snd)
                playSound(snd);
              drawShape(pp, h.t, c);
              break;
            case "stars":
              if (i === 0 && Math.sin(t * 2 + (pp.tw || 0)) > 0.95 && snd)
                playSound(snd);
              drawShape(pp, h.t, c);
              break;
            case "rays":
              if (i === 0) {
                cx.save();
                cx.translate(pp.x, pp.y);
                for (let j = 0; j < 12; j++) {
                  const ang = (j / 12) * Math.PI * 2 + t * 0.2;
                  const len = pp.s * (0.5 + Math.sin(t * 2 + j) * 0.2);
                  const gr = cx.createLinearGradient(
                    0,
                    0,
                    Math.cos(ang) * len,
                    Math.sin(ang) * len
                  );
                  gr.addColorStop(0, c[0]);
                  gr.addColorStop(1, "rgba(255,215,0,0)");
                  cx.beginPath();
                  cx.moveTo(0, 0);
                  cx.lineTo(Math.cos(ang) * len, Math.sin(ang) * len);
                  cx.strokeStyle = gr;
                  cx.lineWidth = 8;
                  cx.stroke();
                }
                cx.font = "60px Arial";
                cx.textAlign = "center";
                cx.textBaseline = "middle";
                cx.fillText("‚ú®", 0, 0);
                cx.restore();
              }
              break;
            case "fireworks":
              // Rakieta startuje - rzadziej
              if (!pp.expl && !pp.fw && Math.random() < 0.008) {
                pp.x = W * 0.15 + Math.random() * W * 0.7;
                pp.y = H;
                pp.ty = H * 0.12 + Math.random() * H * 0.25;
                pp.vy = -10 - Math.random() * 5;
                pp.expl = true;
                pp.trail = [];
                playSound("launch");
              }
              // Rakieta leci w g√≥rƒô
              if (pp.expl && !pp.fw) {
                pp.y += pp.vy;
                pp.vy += 0.18;
                pp.trail.push({ x: pp.x, y: pp.y, a: 1 });
                if (pp.trail.length > 10) pp.trail.shift();
                for (let k = 0; k < pp.trail.length; k++) {
                  const tr = pp.trail[k];
                  tr.a *= 0.8;
                  cx.beginPath();
                  cx.arc(tr.x, tr.y, 3 * (k / pp.trail.length), 0, Math.PI * 2);
                  cx.fillStyle = `rgba(255,180,80,${tr.a})`;
                  cx.fill();
                }
                cx.beginPath();
                cx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
                cx.fillStyle = "#fff";
                cx.shadowColor = "#ff0";
                cx.shadowBlur = 15;
                cx.fill();
                cx.shadowBlur = 0;
                if (pp.y <= pp.ty || pp.vy >= 0) {
                  playSound("explode");
                  for (let j = 0; j < 50; j++) {
                    const ang = (j / 50) * Math.PI * 2 + Math.random() * 0.4;
                    const spd = 2 + Math.random() * 5;
                    p.push({
                      x: pp.x,
                      y: pp.y,
                      vx: Math.cos(ang) * spd * (0.6 + Math.random() * 0.4),
                      vy: Math.sin(ang) * spd * (0.6 + Math.random() * 0.4),
                      s: 4 + Math.random() * 4,
                      c: c[Math.floor(Math.random() * 3)],
                      life: 1,
                      decay: 0.018 + Math.random() * 0.012,
                      fw: true,
                      trail: [],
                    });
                  }
                  pp.expl = false;
                  pp.y = H + 200;
                  pp.trail = [];
                }
              }
              // CzƒÖsteczki eksplozji
              if (pp.fw && pp.life > 0) {
                pp.x += pp.vx;
                pp.y += pp.vy;
                pp.vy += 0.12;
                pp.vx *= 0.96;
                pp.vy *= 0.96;
                pp.life -= pp.decay;
                pp.trail.push({ x: pp.x, y: pp.y, a: pp.life });
                if (pp.trail.length > 5) pp.trail.shift();
                for (let k = 0; k < pp.trail.length; k++) {
                  const tr = pp.trail[k];
                  const sz =
                    pp.s * 0.25 * (k / pp.trail.length) * Math.max(0, tr.a);
                  if (sz > 0.2) {
                    cx.beginPath();
                    cx.arc(tr.x, tr.y, sz, 0, Math.PI * 2);
                    cx.fillStyle = hexToRgba(pp.c, tr.a * 0.3);
                    cx.fill();
                  }
                }
                const sz = Math.max(0.3, pp.s * pp.life * 0.8);
                cx.beginPath();
                cx.arc(pp.x, pp.y, sz, 0, Math.PI * 2);
                cx.fillStyle = hexToRgba(pp.c, pp.life * 0.9);
                cx.shadowColor = pp.c;
                cx.shadowBlur = 10 * pp.life;
                cx.fill();
                cx.shadowBlur = 0;
              }
              break;
          }
        }
      }

      function hexToRgba(hex, a) {
        if (!hex) return `rgba(255,255,255,${a})`;
        if (hex.startsWith("rgb"))
          return hex.replace(")", `,${a})`).replace("rgb", "rgba");
        const r = parseInt(hex.slice(1, 3), 16),
          g = parseInt(hex.slice(3, 5), 16),
          b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${a})`;
      }

      function drawShape(pp, type, c) {
        cx.save();
        cx.translate(pp.x, pp.y);
        cx.rotate(pp.r || 0);
        const s = pp.s || 30;
        const col = pp.c || c[0];

        // Glow effect for some types
        if (
          ["glow", "stars", "candles"].some((x) => type.includes(x)) ||
          type === "allsaints" ||
          type === "allsouls" ||
          type === "presentation" ||
          type === "stlucy" ||
          type === "standrew" ||
          type === "advent1" ||
          type === "gaudete" ||
          type === "holysat" ||
          type === "stbarbara"
        ) {
          const fl = 0.7 + Math.sin(t * 3 + pp.ph) * 0.3;
          const gs = Math.max(1, s * 1.2);
          const gl = cx.createRadialGradient(0, -s * 0.1, 0, 0, -s * 0.1, gs);
          gl.addColorStop(0, hexToRgba(col, fl * 0.6));
          gl.addColorStop(1, "rgba(255,200,100,0)");
          cx.fillStyle = gl;
          cx.fillRect(-gs, -gs, gs * 2, gs * 2);
        }

        // Twinkling for stars
        if (
          type === "epiphany" ||
          type === "nativitymary" ||
          type === "holyfamily"
        ) {
          const tw = 0.5 + Math.sin(t * 2 + (pp.tw || 0)) * 0.5;
          cx.globalAlpha = tw;
        }

        // Draw based on holiday type
        if (type === "valentine" || type === "sacredheart") {
          drawHeart(s * 0.8, col);
        } else if (type === "easter" || type === "eastermon") {
          drawEgg(s, c);
        } else if (type === "stpatrick") {
          drawClover(s * 0.7, col);
        } else if (type === "halloween") {
          drawPumpkin(s, c);
        } else if (
          type === "christmas" ||
          type === "christmas2" ||
          type === "ststephen" ||
          type === "stjohnevang"
        ) {
          drawSnowflake(s * 0.6, col);
        } else if (type === "stnicolas") {
          drawGift(s * 0.8, c);
        } else if (
          type === "epiphany" ||
          type === "nativitymary" ||
          type === "holyfamily"
        ) {
          drawStar(s * 0.7, col);
        } else if (
          type === "goodfriday" ||
          type === "holycross" ||
          type === "ashwed"
        ) {
          drawCross(s * 0.8, col);
        } else if (type === "pentecost" || type === "stjohn") {
          drawFlame(s * 0.7, c);
        } else if (type === "palm" || type === "stbarbara") {
          drawLeaf(s * 0.8, col);
        } else if (
          type === "corpuschristi" ||
          type === "labor" ||
          type === "annunciation" ||
          type === "immaculate" ||
          type === "assumption" ||
          type === "czestochowa"
        ) {
          drawFlower(s * 0.6, c);
        } else if (type === "constitution" || type === "independence") {
          drawFlag(s, c);
        } else if (type === "baptism") {
          drawDrop(s * 0.6, col);
        } else if (type === "stmartin") {
          drawLantern(s * 0.7, c);
        } else if (type === "ascension" || type === "innocents") {
          drawCloud(s * 0.8, col);
        } else if (type === "peterpoul") {
          drawKey(s * 0.7, col);
        } else if (type === "christking" || type === "czestochowa") {
          drawCrown(s * 0.7, col);
        } else if (type === "rosary") {
          drawRosary(s * 0.5, col);
        } else if (type === "holythurs") {
          drawBread(s * 0.7, col);
        } else {
          // Default: candle/light
          drawCandle(s * 0.6, c);
        }
        cx.restore();
      }

      function drawHeart(s, col) {
        cx.beginPath();
        cx.moveTo(0, -s * 0.3);
        cx.bezierCurveTo(-s * 0.5, -s * 0.8, -s, -s * 0.2, -s * 0.1, s * 0.4);
        cx.lineTo(0, s * 0.6);
        cx.lineTo(s * 0.1, s * 0.4);
        cx.bezierCurveTo(s, -s * 0.2, s * 0.5, -s * 0.8, 0, -s * 0.3);
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 15;
        cx.fill();
      }

      function drawEgg(s, c) {
        cx.beginPath();
        cx.ellipse(0, 0, s * 0.35, s * 0.5, 0, 0, Math.PI * 2);
        const gr = cx.createLinearGradient(-s * 0.3, 0, s * 0.3, 0);
        gr.addColorStop(0, c[0]);
        gr.addColorStop(0.5, c[1]);
        gr.addColorStop(1, c[2]);
        cx.fillStyle = gr;
        cx.fill();
        cx.strokeStyle = c[2];
        cx.lineWidth = 2;
        for (let i = -2; i <= 2; i++) {
          cx.beginPath();
          cx.moveTo(-s * 0.25, i * s * 0.12);
          cx.bezierCurveTo(
            -s * 0.1,
            i * s * 0.12 + Math.sin(t * 2 + i) * 4,
            s * 0.1,
            i * s * 0.12 - Math.sin(t * 2 + i) * 4,
            s * 0.25,
            i * s * 0.12
          );
          cx.stroke();
        }
      }

      function drawClover(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 10;
        for (let i = 0; i < 3; i++) {
          cx.beginPath();
          const ang = (i / 3) * Math.PI * 2 - Math.PI / 2;
          cx.arc(
            Math.cos(ang) * s * 0.25,
            Math.sin(ang) * s * 0.25 - s * 0.1,
            s * 0.25,
            0,
            Math.PI * 2
          );
          cx.fill();
        }
        cx.fillRect(-s * 0.06, 0, s * 0.12, s * 0.5);
      }

      function drawPumpkin(s, c) {
        const glow = 0.5 + Math.sin(t * 2) * 0.3;
        cx.beginPath();
        cx.ellipse(0, 0, s * 0.45, s * 0.35, 0, 0, Math.PI * 2);
        const gr = cx.createRadialGradient(
          -s * 0.1,
          -s * 0.1,
          0,
          0,
          0,
          s * 0.45
        );
        gr.addColorStop(0, c[0]);
        gr.addColorStop(1, "#cc5500");
        cx.fillStyle = gr;
        cx.fill();
        cx.fillStyle = `rgba(255,200,0,${glow})`;
        cx.beginPath();
        cx.moveTo(-s * 0.15, -s * 0.05);
        cx.lineTo(-s * 0.08, -s * 0.15);
        cx.lineTo(-s * 0.02, -s * 0.05);
        cx.fill();
        cx.beginPath();
        cx.moveTo(s * 0.15, -s * 0.05);
        cx.lineTo(s * 0.08, -s * 0.15);
        cx.lineTo(s * 0.02, -s * 0.05);
        cx.fill();
        cx.beginPath();
        cx.moveTo(-s * 0.12, s * 0.08);
        cx.lineTo(0, s * 0.15);
        cx.lineTo(s * 0.12, s * 0.08);
        cx.lineTo(0, s * 0.05);
        cx.fill();
        cx.fillStyle = "#228B22";
        cx.fillRect(-s * 0.04, -s * 0.4, s * 0.08, s * 0.12);
      }

      function drawSnowflake(s, col) {
        cx.strokeStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 10;
        cx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
          cx.save();
          cx.rotate((i * Math.PI) / 3);
          cx.beginPath();
          cx.moveTo(0, 0);
          cx.lineTo(0, -s);
          cx.moveTo(0, -s * 0.5);
          cx.lineTo(-s * 0.2, -s * 0.7);
          cx.moveTo(0, -s * 0.5);
          cx.lineTo(s * 0.2, -s * 0.7);
          cx.stroke();
          cx.restore();
        }
      }

      function drawGift(s, c) {
        cx.fillStyle = c[0];
        cx.fillRect(-s * 0.4, -s * 0.3, s * 0.8, s * 0.6);
        cx.fillStyle = c[1];
        cx.fillRect(-s * 0.08, -s * 0.3, s * 0.16, s * 0.6);
        cx.fillRect(-s * 0.4, -s * 0.08, s * 0.8, s * 0.16);
        cx.fillStyle = c[2];
        cx.beginPath();
        cx.ellipse(-s * 0.2, -s * 0.4, s * 0.15, s * 0.1, 0, 0, Math.PI * 2);
        cx.ellipse(s * 0.2, -s * 0.4, s * 0.15, s * 0.1, 0, 0, Math.PI * 2);
        cx.fill();
      }

      function drawStar(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 20;
        cx.beginPath();
        for (let i = 0; i < 5; i++) {
          const ang = (i * Math.PI * 2) / 5 - Math.PI / 2;
          const r = i % 2 === 0 ? s : s * 0.4;
          cx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
        }
        cx.closePath();
        cx.fill();
      }

      function drawCross(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 15;
        cx.fillRect(-s * 0.12, -s * 0.5, s * 0.24, s);
        cx.fillRect(-s * 0.35, -s * 0.25, s * 0.7, s * 0.2);
      }

      function drawFlame(s, c) {
        cx.beginPath();
        cx.moveTo(0, s * 0.5);
        cx.quadraticCurveTo(-s * 0.4, 0, -s * 0.2, -s * 0.3);
        cx.quadraticCurveTo(0, -s * 0.6, 0, -s * 0.5);
        cx.quadraticCurveTo(0, -s * 0.6, s * 0.2, -s * 0.3);
        cx.quadraticCurveTo(s * 0.4, 0, 0, s * 0.5);
        const gr = cx.createLinearGradient(0, -s * 0.5, 0, s * 0.5);
        gr.addColorStop(0, c[1]);
        gr.addColorStop(0.5, c[0]);
        gr.addColorStop(1, c[2]);
        cx.fillStyle = gr;
        cx.shadowColor = c[0];
        cx.shadowBlur = 20;
        cx.fill();
      }

      function drawLeaf(s, col) {
        cx.fillStyle = col;
        cx.beginPath();
        cx.moveTo(0, -s * 0.5);
        cx.quadraticCurveTo(s * 0.4, -s * 0.2, s * 0.3, s * 0.3);
        cx.quadraticCurveTo(0, s * 0.5, 0, s * 0.5);
        cx.quadraticCurveTo(0, s * 0.5, -s * 0.3, s * 0.3);
        cx.quadraticCurveTo(-s * 0.4, -s * 0.2, 0, -s * 0.5);
        cx.fill();
        cx.strokeStyle = "rgba(0,0,0,0.3)";
        cx.lineWidth = 1;
        cx.beginPath();
        cx.moveTo(0, -s * 0.4);
        cx.lineTo(0, s * 0.4);
        cx.stroke();
      }

      function drawFlower(s, c) {
        cx.fillStyle = c[0];
        for (let i = 0; i < 5; i++) {
          cx.beginPath();
          const ang = (i * Math.PI * 2) / 5;
          cx.ellipse(
            Math.cos(ang) * s * 0.3,
            Math.sin(ang) * s * 0.3,
            s * 0.25,
            s * 0.15,
            ang,
            0,
            Math.PI * 2
          );
          cx.fill();
        }
        cx.fillStyle = c[1];
        cx.beginPath();
        cx.arc(0, 0, s * 0.2, 0, Math.PI * 2);
        cx.fill();
      }

      function drawFlag(s, c) {
        cx.fillStyle = "#8B4513";
        cx.fillRect(-s * 0.05, -s * 0.5, s * 0.1, s);
        cx.fillStyle = c[0];
        cx.fillRect(s * 0.05, -s * 0.5, s * 0.6, s * 0.25);
        cx.fillStyle = c[1];
        cx.fillRect(s * 0.05, -s * 0.25, s * 0.6, s * 0.25);
      }

      function drawDrop(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 10;
        cx.beginPath();
        cx.moveTo(0, -s * 0.5);
        cx.quadraticCurveTo(s * 0.4, s * 0.1, 0, s * 0.5);
        cx.quadraticCurveTo(-s * 0.4, s * 0.1, 0, -s * 0.5);
        cx.fill();
      }

      function drawLantern(s, c) {
        const glow = 0.6 + Math.sin(t * 2) * 0.3;
        cx.fillStyle = c[0];
        cx.fillRect(-s * 0.3, -s * 0.4, s * 0.6, s * 0.7);
        cx.fillStyle = `rgba(255,200,100,${glow})`;
        cx.fillRect(-s * 0.2, -s * 0.3, s * 0.4, s * 0.5);
        cx.strokeStyle = c[1];
        cx.lineWidth = 3;
        cx.strokeRect(-s * 0.3, -s * 0.4, s * 0.6, s * 0.7);
        cx.beginPath();
        cx.moveTo(0, -s * 0.4);
        cx.lineTo(0, -s * 0.6);
        cx.stroke();
      }

      function drawCloud(s, col) {
        cx.fillStyle = col;
        cx.globalAlpha = 0.8;
        cx.beginPath();
        cx.arc(-s * 0.25, 0, s * 0.25, 0, Math.PI * 2);
        cx.arc(s * 0.15, 0, s * 0.3, 0, Math.PI * 2);
        cx.arc(s * 0.4, s * 0.05, s * 0.2, 0, Math.PI * 2);
        cx.fill();
      }

      function drawKey(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 10;
        cx.beginPath();
        cx.arc(0, -s * 0.3, s * 0.2, 0, Math.PI * 2);
        cx.fill();
        cx.fillRect(-s * 0.06, -s * 0.1, s * 0.12, s * 0.6);
        cx.fillRect(-s * 0.15, s * 0.3, s * 0.2, s * 0.08);
        cx.fillRect(-s * 0.15, s * 0.45, s * 0.15, s * 0.08);
      }

      function drawCrown(s, col) {
        cx.fillStyle = col;
        cx.shadowColor = col;
        cx.shadowBlur = 15;
        cx.beginPath();
        cx.moveTo(-s * 0.4, s * 0.2);
        cx.lineTo(-s * 0.4, -s * 0.1);
        cx.lineTo(-s * 0.25, -s * 0.3);
        cx.lineTo(-s * 0.1, -s * 0.1);
        cx.lineTo(0, -s * 0.4);
        cx.lineTo(s * 0.1, -s * 0.1);
        cx.lineTo(s * 0.25, -s * 0.3);
        cx.lineTo(s * 0.4, -s * 0.1);
        cx.lineTo(s * 0.4, s * 0.2);
        cx.closePath();
        cx.fill();
      }

      function drawRosary(s, col) {
        cx.strokeStyle = col;
        cx.lineWidth = 2;
        cx.beginPath();
        cx.arc(0, 0, s * 0.4, 0, Math.PI * 2);
        cx.stroke();
        cx.fillStyle = col;
        for (let i = 0; i < 10; i++) {
          const ang = (i * Math.PI * 2) / 10;
          cx.beginPath();
          cx.arc(
            Math.cos(ang) * s * 0.4,
            Math.sin(ang) * s * 0.4,
            s * 0.08,
            0,
            Math.PI * 2
          );
          cx.fill();
        }
        cx.beginPath();
        cx.moveTo(0, s * 0.4);
        cx.lineTo(0, s * 0.7);
        cx.stroke();
        drawCross(s * 0.3, col);
        cx.translate(0, s * 0.8);
      }

      function drawBread(s, col) {
        cx.fillStyle = col;
        cx.beginPath();
        cx.ellipse(0, 0, s * 0.5, s * 0.3, 0, 0, Math.PI * 2);
        cx.fill();
        cx.strokeStyle = "rgba(139,69,19,0.5)";
        cx.lineWidth = 2;
        cx.beginPath();
        cx.moveTo(-s * 0.3, -s * 0.1);
        cx.lineTo(s * 0.3, -s * 0.1);
        cx.moveTo(-s * 0.2, s * 0.1);
        cx.lineTo(s * 0.2, s * 0.1);
        cx.stroke();
      }

      function drawCandle(s, c) {
        const fl = 0.7 + Math.sin(t * 4 + Math.random() * 0.5) * 0.3;
        cx.fillStyle = c[0] || "#fff";
        cx.fillRect(-s * 0.15, 0, s * 0.3, s * 0.6);
        cx.fillStyle = c[1] || "#FFD700";
        cx.beginPath();
        cx.ellipse(0, -s * 0.1, s * 0.12, s * 0.2, 0, 0, Math.PI * 2);
        cx.fill();
        const gs = Math.max(1, s * 0.8);
        const gl = cx.createRadialGradient(0, -s * 0.15, 0, 0, -s * 0.15, gs);
        gl.addColorStop(0, `rgba(255,200,100,${fl * 0.5})`);
        gl.addColorStop(1, "rgba(255,200,100,0)");
        cx.fillStyle = gl;
        cx.fillRect(-gs, -gs, gs * 2, gs * 2);
      }

      function drawSky(alt) {
        let g;
        if (alt > 15) {
          g = cx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, "#1e90ff");
          g.addColorStop(0.5, "#87ceeb");
          g.addColorStop(1, "#b0e0e6");
        } else if (alt > 0) {
          const tt = alt / 15;
          g = cx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, lc("#ff7e5f", "#1e90ff", tt));
          g.addColorStop(0.4, lc("#feb47b", "#87ceeb", tt));
          g.addColorStop(1, "#b0e0e6");
        } else if (alt > -6) {
          const tt = (alt + 6) / 6;
          g = cx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, lc("#2c2c54", "#ff7e5f", tt));
          g.addColorStop(0.5, lc("#3d3d6b", "#feb47b", tt));
          g.addColorStop(1, lc("#16213e", "#87ceeb", tt));
        } else {
          g = cx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, "#0a0a1a");
          g.addColorStop(0.5, "#1a1a2e");
          g.addColorStop(1, "#16213e");
        }
        cx.fillStyle = g;
        cx.fillRect(0, 0, W, H);
      }
      function drawGnd(alt) {
        const gY = H * 0.85,
          tt = Math.min(1, Math.max(0, -alt / 12)),
          g = cx.createLinearGradient(0, gY, 0, H);
        g.addColorStop(0, lc("#228B22", "#0d1f0d", tt));
        g.addColorStop(1, lc("#1a6b1a", "#050a05", tt));
        cx.fillStyle = g;
        cx.fillRect(0, gY, W, H - gY);
      }
      function drawStars(alt) {
        if (alt > 5) return;
        const vis = Math.min(1, (5 - alt) / 17);
        for (const s of stars) {
          const tw = Math.sin(t * s.sp + s.o) * 0.4 + 0.6;
          cx.beginPath();
          cx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
          cx.fillStyle = `rgba(255,255,255,${vis * tw})`;
          cx.fill();
        }
      }
      function drawSun(sun) {
        if (sun.alt < -5) return;
        const x = ((sun.az - 90) / 180) * W,
          y = H * 0.85 - (sun.alt / 90) * H * 0.7,
          sz = Math.max(1, Math.min(W, H) * 0.07),
          al = sun.alt > 0 ? 1 : Math.max(0, (sun.alt + 5) / 5),
          gs = Math.max(1, sz * 3),
          gl = cx.createRadialGradient(x, y, 0, x, y, gs);
        gl.addColorStop(0, `rgba(255,215,0,${al * 0.6})`);
        gl.addColorStop(0.5, `rgba(255,165,0,${al * 0.2})`);
        gl.addColorStop(1, "rgba(255,165,0,0)");
        cx.fillStyle = gl;
        cx.beginPath();
        cx.arc(x, y, gs, 0, Math.PI * 2);
        cx.fill();
        const sg = cx.createRadialGradient(
          x - sz * 0.2,
          y - sz * 0.2,
          0,
          x,
          y,
          sz
        );
        sg.addColorStop(0, `rgba(255,248,200,${al})`);
        sg.addColorStop(0.5, `rgba(255,215,0,${al})`);
        sg.addColorStop(1, `rgba(255,165,0,${al})`);
        cx.fillStyle = sg;
        cx.beginPath();
        cx.arc(x, y, sz, 0, Math.PI * 2);
        cx.fill();
      }
      function drawMoon(sun) {
        if (sun.alt > 5) return;
        const mAz = (sun.az + 180) % 360,
          x = ((mAz - 90) / 180) * W,
          y = H * 0.3 + Math.sin(t * 0.1) * 10,
          sz = Math.max(1, Math.min(W, H) * 0.05),
          al = sun.alt < -5 ? 1 : Math.max(0, (5 - sun.alt) / 10),
          gs = Math.max(1, sz * 2.5),
          gl = cx.createRadialGradient(x, y, 0, x, y, gs);
        gl.addColorStop(0, `rgba(255,250,205,${al * 0.4})`);
        gl.addColorStop(1, "rgba(255,250,205,0)");
        cx.fillStyle = gl;
        cx.beginPath();
        cx.arc(x, y, gs, 0, Math.PI * 2);
        cx.fill();
        const mg = cx.createRadialGradient(
          x - sz * 0.3,
          y - sz * 0.3,
          0,
          x,
          y,
          sz
        );
        mg.addColorStop(0, `rgba(255,255,240,${al})`);
        mg.addColorStop(0.7, `rgba(240,230,140,${al})`);
        mg.addColorStop(1, `rgba(218,165,32,${al})`);
        cx.fillStyle = mg;
        cx.beginPath();
        cx.arc(x, y, sz, 0, Math.PI * 2);
        cx.fill();
      }

      function fmtC(ms) {
        const d = Math.floor(ms / 864e5),
          h = Math.floor((ms % 864e5) / 36e5),
          m = Math.floor((ms % 36e5) / 6e4),
          s = Math.floor((ms % 6e4) / 1e3);
        return d > 0 ? `${d}d ${h}h ${m}m ${s}s` : `${h}h ${m}m ${s}s`;
      }
      function updClk() {
        const now = new Date(),
          ts = now.toLocaleTimeString("pl-PL", {
            timeZone: tz,
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          }),
          ds = now.toLocaleDateString("pl-PL", {
            timeZone: tz,
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });
        document.getElementById("time").textContent = ts;
        document.getElementById("date").textContent =
          ds.charAt(0).toUpperCase() + ds.slice(1);
        const td = new Date(now.toLocaleString("en-US", { timeZone: tz })),
          hol = getCur(td),
          ne = document.getElementById("hname"),
          ce = document.getElementById("count");
        if (pm) {
          const ph = hs.find((x) => x.t === pm);
          if (ph) {
            ne.textContent = `üëÅÔ∏è PodglƒÖd: ${ph.n}`;
            ce.textContent = 'Kliknij "Zatrzymaj" by wr√≥ciƒá';
          }
          return td;
        }
        if (hol) {
          ne.textContent = `üéâ ${hol.n} üéâ`;
          ce.textContent = "";
          if (cht !== hol.t) {
            cht = hol.t;
            initP(hol);
          }
        } else {
          if (cht) {
            cht = null;
            p = [];
          }
          const nx = getNext(td);
          if (nx) {
            ne.textContent = `Nastƒôpne: ${nx.n}`;
            ce.textContent = `Za: ${fmtC(nx.date - td)}`;
          }
        }
        return td;
      }

      let lt = 0;
      function anim(ts) {
        const dt = (ts - lt) / 1000;
        lt = ts;
        t += dt;
        const td = updClk(),
          sun = getSun(td);
        cx.clearRect(0, 0, W, H);
        drawSky(sun.alt);
        drawStars(sun.alt);
        drawMoon(sun);
        drawSun(sun);
        drawGnd(sun.alt);
        const at = pm || cht;
        if (at) {
          const h = hs.find((x) => x.t === at);
          if (h) updP(h);
        }
        p = p.filter((x) => !x.fw || x.life > 0);
        requestAnimationFrame(anim);
      }

      function toggleSettings() {
        document.getElementById("spanel").classList.toggle("open");
      }
      function toggleSound() {
        initAudio();
        soundEnabled = !soundEnabled;
        const btn = document.getElementById("sndbtn");
        btn.textContent = soundEnabled ? "üîä" : "üîá";
        btn.classList.toggle("muted", !soundEnabled);
        localStorage.setItem(
          "fv5",
          JSON.stringify({ tz, c: hc, snd: soundEnabled })
        );
        if (soundEnabled) {
          playSound("chime", true);
          const at = pm || cht;
          if (at) startAmbient(at);
        } else {
          stopAmbient();
        }
      }
      function togglePreview(t) {
        initAudio();
        document.querySelectorAll(".pb").forEach((b) => {
          b.classList.remove("active");
          b.innerHTML = "‚ñ∂Ô∏è Zobacz";
        });
        if (pm === t) {
          pm = null;
          stopAmbient();
          const now = new Date(),
            td = new Date(now.toLocaleString("en-US", { timeZone: tz })),
            hol = getCur(td);
          if (hol) {
            cht = hol.t;
            initP(hol);
            startAmbient(hol.t);
          } else {
            cht = null;
            p = [];
          }
        } else {
          pm = t;
          const btn = document.getElementById("pb-" + t);
          if (btn) {
            btn.classList.add("active");
            btn.innerHTML = "‚èπÔ∏è Stop";
          }
          const h = hs.find((x) => x.t === t);
          if (h) {
            cht = t;
            initP(h);
            startAmbient(t);
          }
        }
      }
      function genSet() {
        const ct = document.getElementById("hset");
        ct.innerHTML = "";
        const uq = hs.filter(
          (h, i, a) => a.findIndex((x) => x.t === h.t) === i
        );
        for (const h of uq) {
          const cs = gc(h),
            dv = document.createElement("div");
          dv.className = "hi";
          dv.setAttribute("data-type", h.t);
          dv.setAttribute("data-name", h.n.toLowerCase());
          dv.innerHTML = `<div class="hh"><span class="hn">${h.e} ${
            h.n
          }</span><span class="hd">${
            h.mv ? "Ruchome" : `${h.d}.${h.m}`
          }</span></div><div class="ci">${cs
            .map(
              (c, i) =>
                `<div class="cg"><label>Kolor ${
                  i + 1
                }</label><input type="color" id="col-${
                  h.t
                }-${i}" value="${c}" onchange="updC('${
                  h.t
                }',${i},this.value)"></div>`
            )
            .join(
              ""
            )}</div><div class="pl">PodglƒÖd:</div><button class="pb" id="pb-${
            h.t
          }" onclick="togglePreview('${h.t}')">‚ñ∂Ô∏è Zobacz</button>`;
          ct.appendChild(dv);
        }
      }
      function filterHolidays(query) {
        const q = query.toLowerCase().trim();
        const items = document.querySelectorAll(".hi");
        items.forEach((item) => {
          const name = item.getAttribute("data-name");
          if (!q || name.includes(q)) {
            item.classList.remove("hidden");
          } else {
            item.classList.add("hidden");
          }
        });
      }
      function clearSearch() {
        document.getElementById("searchInput").value = "";
        filterHolidays("");
      }
      function updC(t, i, c) {
        if (!hc[t]) {
          const h = hs.find((x) => x.t === t);
          hc[t] = [...h.c];
        }
        hc[t][i] = c;
        localStorage.setItem(
          "fv5",
          JSON.stringify({ tz, c: hc, snd: soundEnabled })
        );
        const h = hs.find((x) => x.t === t);
        if (h && (cht === t || pm === t)) {
          const cols = gc(h);
          p.forEach((pp, idx) => {
            if (!pp.fw) pp.c = cols[idx % 3];
          });
          initP(h);
        }
      }
      function load() {
        const s = localStorage.getItem("fv5");
        if (s) {
          try {
            const d = JSON.parse(s);
            tz = d.tz || "Europe/Warsaw";
            hc = d.c || {};
            if (typeof d.snd === "boolean") {
              soundEnabled = d.snd;
              const btn = document.getElementById("sndbtn");
              btn.textContent = soundEnabled ? "üîä" : "üîá";
              btn.classList.toggle("muted", !soundEnabled);
            }
            document.querySelector("#tz select").value = tz;
          } catch (e) {
            hc = {};
          }
        }
      }
      function changeTimezone() {
        tz = document.querySelector("#tz select").value;
        localStorage.setItem(
          "fv5",
          JSON.stringify({ tz, c: hc, snd: soundEnabled })
        );
      }

      load();
      genSet();
      const now = new Date(),
        td = new Date(now.toLocaleString("en-US", { timeZone: tz })),
        hol = getCur(td);
      if (hol) {
        cht = hol.t;
        initP(hol);
      }
      document.getElementById("sbtn").onclick = toggleSettings;
      // Start ambient po pierwszej interakcji
      document.addEventListener(
        "click",
        () => {
          initAudio();
          if (soundEnabled && cht) startAmbient(cht);
        },
        { once: true }
      );
      requestAnimationFrame(anim);
    </script>
  </body>
</html>
